<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Flight Simulator with Enhanced Features</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #score {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            color: white;
            font-family: Arial, sans-serif;
            text-shadow: 2px 2px 4px black;
        }
        #speed {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 24px;
            color: white;
            font-family: Arial, sans-serif;
            text-shadow: 2px 2px 4px black;
        }
        #altitude {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 24px;
            color: white;
            font-family: Arial, sans-serif;
            text-shadow: 2px 2px 4px black;
        }
        #startMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 36px;
            color: white;
            font-family: Arial, sans-serif;
            text-shadow: 2px 2px 4px black;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: red;
            font-family: Arial, sans-serif;
            text-align: center;
            text-shadow: 2px 2px 4px black;
        }
    </style>
</head>
<body>
    <div id="score">Score: 0</div>
    <div id="speed">Speed: 0 blocks/s</div>
    <div id="altitude">Altitude: 0 blocks</div>
    <div id="startMessage">Press Spacebar to take-off</div>
    <!-- Include Three.js library via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialize the Three.js scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            2000
        );
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Enable shadows
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Declare variables in outer scope
        let planeGroup;
        const planeParts = [];
        let buildings = [];
        let vehicles = [];
        let boats = [];
        let clouds = [];

        // Flight mechanics variables
        const baseSpeed = 1;
        const g = -0.02;
        const pitchRate = 0.01;
        const yawRate = 0.005;
        let pitch = 0;
        let yaw = Math.PI;
        let engineOn = false;
        let velocity = new THREE.Vector3(0, 0, 0);
        const keys = {};
        let gameOver = false;
        let score = 0;
        let lastTime = performance.now();
        let hasStarted = false;

        // UI elements
        const scoreElement = document.getElementById('score');
        const speedElement = document.getElementById('speed');
        const altitudeElement = document.getElementById('altitude');
        const startMessageElement = document.getElementById('startMessage');

        // Texture loader with error handling
        const loader = new THREE.TextureLoader();
        const loadTexture = (path, fallbackColor) => {
            return new Promise((resolve) => {
                loader.load(
                    path,
                    (texture) => resolve(texture),
                    undefined,
                    (error) => {
                        console.error(`Texture not found: ${path}, using fallback color.`);
                        resolve(null);
                    }
                );
            });
        };

        // Load textures with updated path ./assets/
        Promise.all([
            loadTexture('./assets/grass.png').then((texture) => {
                if (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(10, 10);
                    return new THREE.MeshLambertMaterial({ map: texture });
                } else {
                    return new THREE.MeshLambertMaterial({ color: 0x228B22 });
                }
            }),
            loadTexture('./assets/sun.jpg').then((texture) => {
                if (texture) {
                    return new THREE.MeshBasicMaterial({ map: texture });
                } else {
                    return new THREE.MeshBasicMaterial({ color: 0xFFFF00 });
                }
            }),
            loadTexture('./assets/sea.png').then((texture) => {
                if (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(10, 10);
                    return new THREE.MeshLambertMaterial({ map: texture });
                } else {
                    return new THREE.MeshLambertMaterial({ color: 0x0000FF });
                }
            }),
            loadTexture('./assets/sky.png').then((texture) => {
                if (texture) {
                    return new THREE.MeshBasicMaterial({ map: texture });
                } else {
                    return new THREE.MeshBasicMaterial({ color: 0x87CEEB });
                }
            }),
            // Load building textures with updated names
            loadTexture('./assets/building-1.jpg').then((texture) => texture || new THREE.MeshLambertMaterial({ color: 0xaaaaaa })),
            loadTexture('./assets/building-2.jpg').then((texture) => texture || new THREE.MeshLambertMaterial({ color: 0xbbbbbb })),
            loadTexture('./assets/building-3.jpg').then((texture) => texture || new THREE.MeshLambertMaterial({ color: 0xcccccc })),
            loadTexture('./assets/building-4.jpg').then((texture) => texture || new THREE.MeshLambertMaterial({ color: 0xdddddd })),
            loadTexture('./assets/building-5.jpg').then((texture) => texture || new THREE.MeshLambertMaterial({ color: 0xeeeeee }))
        ]).then(([grassMaterial, sunMaterial, seaMaterial, skyMaterial, buildingTexture1, buildingTexture2, buildingTexture3, buildingTexture4, buildingTexture5]) => {
            const buildingTextures = [buildingTexture1, buildingTexture2, buildingTexture3, buildingTexture4, buildingTexture5];

            // Set background to sky texture or fallback color
            scene.background = skyMaterial.color || new THREE.Color(0x87CEEB);

            // Create the sun
            const sunGeometry = new THREE.SphereGeometry(120, 32, 32);
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(0, 800, -200);
            scene.add(sun);

            // Add directional light from the sun's position
            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.copy(sun.position);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 1000;
            sunLight.shadow.camera.left = -200;
            sunLight.shadow.camera.right = 200;
            sunLight.shadow.camera.top = 200;
            sunLight.shadow.camera.bottom = -200;
            scene.add(sunLight);

            // Add ambient light for visibility
            scene.add(new THREE.AmbientLight(0x404040));

            // Create the ground with grass texture or fallback
            const groundSize = 1000;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
            const ground = new THREE.Mesh(groundGeometry, grassMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Create the ocean with sea texture or fallback
            const oceanSize = 2000;
            const oceanGeometry = new THREE.PlaneGeometry(oceanSize, oceanSize);
            const ocean = new THREE.Mesh(oceanGeometry, seaMaterial);
            ocean.rotation.x = -Math.PI / 2;
            ocean.position.y = -0.1;
            scene.add(ocean);

            // Create the airport runway
            const runwayGeometry = new THREE.PlaneGeometry(20, 200);
            const runwayMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
            runway.rotation.x = -Math.PI / 2;
            runway.position.set(0, 0.02, 0);
            runway.receiveShadow = true;
            scene.add(runway);

            // Define exclusion zones with wider buffer around runway
            const runwayExclusionZone = { minX: -50, maxX: 50, minZ: -150, maxZ: 150 };
            const streetWidth = 10;
            const streets = [];
            const roadExclusions = [];

            // Create roads outside the runway area
            const streetMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            for (let i = -groundSize / 2; i <= groundSize / 2; i += 50) {
                if (i < runwayExclusionZone.minZ || i > runwayExclusionZone.maxZ) {
                    const streetH = new THREE.Mesh(new THREE.PlaneGeometry(groundSize, streetWidth), streetMaterial);
                    streetH.rotation.x = -Math.PI / 2;
                    streetH.position.set(0, 0.01, i);
                    streetH.receiveShadow = true;
                    scene.add(streetH);
                    streets.push({ type: 'horizontal', z: i });
                    roadExclusions.push({ minX: -groundSize / 2, maxX: groundSize / 2, minZ: i - streetWidth / 2, maxZ: i + streetWidth / 2 });
                }
                if (Math.abs(i) > 50) {
                    const streetV = new THREE.Mesh(new THREE.PlaneGeometry(streetWidth, groundSize), streetMaterial);
                    streetV.rotation.x = -Math.PI / 2;
                    streetV.position.set(i, 0.01, 0);
                    streetV.receiveShadow = true;
                    scene.add(streetV);
                    streets.push({ type: 'vertical', x: i });
                    roadExclusions.push({ minX: i - streetWidth / 2, maxX: i + streetWidth / 2, minZ: -groundSize / 2, maxZ: groundSize / 2 });
                }
            }

            // Add road markings (center lines)
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            for (let i = -groundSize / 2; i <= groundSize / 2; i += 50) {
                if (i < runwayExclusionZone.minZ || i > runwayExclusionZone.maxZ) {
                    for (let j = -groundSize / 2; j < groundSize / 2; j += 10) {
                        const line = new THREE.Mesh(new THREE.PlaneGeometry(5, 0.5), lineMaterial);
                        line.rotation.x = -Math.PI / 2;
                        line.position.set(j, 0.02, i);
                        scene.add(line);
                    }
                }
                if (Math.abs(i) > 50) {
                    for (let j = -groundSize / 2; j < groundSize / 2; j += 10) {
                        const line = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 5), lineMaterial);
                        line.rotation.x = -Math.PI / 2;
                        line.position.set(i, 0.02, j);
                        scene.add(line);
                    }
                }
            }

            // Generate random buildings with textures
            for (let i = 0; i < 300; i++) {
                let x, z;
                let overlap;
                do {
                    overlap = false;
                    x = (Math.random() - 0.5) * groundSize;
                    z = (Math.random() - 0.5) * groundSize;
                    const width = Math.random() * 10 + 5;
                    const depth = Math.random() * 10 + 5;
                    const buildingZone = { minX: x - width / 2, maxX: x + width / 2, minZ: z - depth / 2, maxZ: z + depth / 2 };

                    if (x > runwayExclusionZone.minX && x < runwayExclusionZone.maxX && z > runwayExclusionZone.minZ && z < runwayExclusionZone.maxZ) {
                        overlap = true;
                        continue;
                    }

                    for (const road of roadExclusions) {
                        if (buildingZone.maxX > road.minX && buildingZone.minX < road.maxX && buildingZone.maxZ > road.minZ && buildingZone.minZ < road.maxZ) {
                            overlap = true;
                            break;
                        }
                    }
                } while (overlap);

                const height = Math.random() * 20 + 10;
                const geometry = new THREE.BoxGeometry(Math.random() * 10 + 5, height, Math.random() * 10 + 5);
                const randomTextureIndex = Math.floor(Math.random() * buildingTextures.length);
                const material = buildingTextures[randomTextureIndex];
                if (material.map) {
                    material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping;
                    material.map.repeat.set(1, height / 10);
                }
                const building = new THREE.Mesh(geometry, material);
                building.position.set(x, height / 2, z);
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
                buildings.push(building);
            }

            // Add moving vehicles on roads
            for (let i = 0; i < 20; i++) {
                const vehicle = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                const startStreet = streets[Math.floor(Math.random() * streets.length)];
                vehicle.position.y = 0.5;
                vehicle.castShadow = true;
                if (startStreet.type === 'horizontal') {
                    vehicle.position.z = startStreet.z + (Math.random() > 0.5 ? 2 : -2);
                    vehicle.position.x = (Math.random() - 0.5) * groundSize;
                    vehicle.direction = Math.random() > 0.5 ? 'east' : 'west';
                    vehicle.rotation.y = Math.PI / 2;
                } else {
                    vehicle.position.x = startStreet.x + (Math.random() > 0.5 ? 2 : -2);
                    vehicle.position.z = (Math.random() - 0.5) * groundSize;
                    vehicle.direction = Math.random() > 0.5 ? 'north' : 'south';
                    vehicle.rotation.y = 0;
                }
                scene.add(vehicle);
                vehicles.push(vehicle);
            }

            // Add larger blocky boats and ships in the ocean
            for (let i = 0; i < 10; i++) {
                const boatGroup = new THREE.Group();
                const hullGeometry = new THREE.BoxGeometry(10, 2, 20);
                const hullMaterial = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
                const hull = new THREE.Mesh(hullGeometry, hullMaterial);
                hull.position.set(0, 1, 0);
                hull.castShadow = true;
                boatGroup.add(hull);

                const cabinGeometry = new THREE.BoxGeometry(6, 3, 6);
                const cabinMaterial = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
                const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
                cabin.position.set(0, 2.5, -5);
                cabin.castShadow = true;
                boatGroup.add(cabin);

                let x, z;
                do {
                    x = (Math.random() - 0.5) * oceanSize;
                    z = (Math.random() - 0.5) * oceanSize;
                } while (Math.abs(x) < groundSize / 2 && Math.abs(z) < groundSize / 2);
                boatGroup.position.set(x, 0, z);
                boatGroup.direction = Math.random() > 0.5 ? 'x' : 'z';
                boatGroup.speed = Math.random() * 0.1 + 0.05;
                boatGroup.rotation.y = boatGroup.direction === 'x' ? Math.PI / 2 : 0;
                scene.add(boatGroup);
                boats.push(boatGroup);
            }

            // Generate Minecraft-style clouds
            for (let i = 0; i < 50; i++) {
                const pattern = cloudPatterns[Math.floor(Math.random() * cloudPatterns.length)];
                const cloudGroup = new THREE.Group();
                pattern.offsets.forEach(offset => {
                    const cloudGeometry = new THREE.BoxGeometry(pattern.size, pattern.size, pattern.size);
                    const cloudMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloud.position.set(offset[0] * pattern.size, 0, offset[1] * pattern.size);
                    cloud.castShadow = true;
                    cloudGroup.add(cloud);
                });
                cloudGroup.position.set(
                    (Math.random() - 0.5) * 500,
                    160 + Math.random() * 20,
                    (Math.random() - 0.5) * 500
                );
                scene.add(cloudGroup);
                clouds.push(cloudGroup);
            }

            // Create the airplane
            planeGroup = new THREE.Group();

            const fuselageGeometry = new THREE.CylinderGeometry(0.5, 0.5, 10, 32);
            const fuselageMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
            const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
            fuselage.rotation.x = Math.PI / 2;
            fuselage.castShadow = true;
            planeGroup.add(fuselage);
            planeParts.push(fuselage);

            const wingGeometry = new THREE.BoxGeometry(15, 0.5, 2);
            const wingMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-7.5, 0, 0);
            leftWing.castShadow = true;
            planeGroup.add(leftWing);
            planeParts.push(leftWing);
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(7.5, 0, 0);
            rightWing.castShadow = true;
            planeGroup.add(rightWing);
            planeParts.push(rightWing);

            const tailGeometry = new THREE.BoxGeometry(3, 0.5, 1);
            const tail = new THREE.Mesh(tailGeometry, wingMaterial);
            tail.position.set(0, 0, 5);
            tail.castShadow = true;
            planeGroup.add(tail);
            planeParts.push(tail);

            const engineGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 32);
            const engineMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
            const leftEngine = new THREE.Mesh(engineGeometry, engineMaterial);
            leftEngine.position.set(-1.5, 0, 0);
            leftEngine.rotation.x = Math.PI / 2;
            planeGroup.add(leftEngine);
            planeParts.push(leftEngine);
            const rightEngine = new THREE.Mesh(engineGeometry, engineMaterial);
            rightEngine.position.set(1.5, 0, 0);
            rightEngine.rotation.x = Math.PI / 2;
            planeGroup.add(rightEngine);
            planeParts.push(rightEngine);

            const cockpitGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const cockpitMaterial = new THREE.MeshLambertMaterial({ color: 0x0000FF });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 0, -5);
            planeGroup.add(cockpit);
            planeParts.push(cockpit);

            const gearGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const gearMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const frontGear = new THREE.Mesh(gearGeometry, gearMaterial);
            frontGear.position.set(0, -0.5, -4);
            planeGroup.add(frontGear);
            planeParts.push(frontGear);
            const leftGear = new THREE.Mesh(gearGeometry, gearMaterial);
            leftGear.position.set(-1.5, -0.5, 0);
            planeGroup.add(leftGear);
            planeParts.push(leftGear);
            const rightGear = new THREE.Mesh(gearGeometry, gearMaterial);
            rightGear.position.set(1.5, -0.5, 0);
            planeGroup.add(rightGear);
            planeParts.push(rightGear);

            // Position the plane on the runway, facing negative z-direction
            planeGroup.position.set(0, 0.5, -90);
            planeGroup.rotation.y = Math.PI;
            scene.add(planeGroup);

            // Keyboard event listeners
            window.addEventListener('keydown', (e) => {
                if (gameOver && e.key === ' ') resetGame();
                else if (e.key === ' ' && !gameOver) {
                    engineOn = !engineOn;
                    if (!hasStarted && engineOn) {
                        hasStarted = true;
                        startMessageElement.style.display = 'none';
                    }
                } else {
                    keys[e.key] = true;
                }
            });
            window.addEventListener('keyup', (e) => keys[e.key] = false);

            // Function to break apart the plane
            function breakApartPlane() {
                planeParts.forEach(part => {
                    const randomVelocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    );
                    part.userData.velocity = randomVelocity;
                    part.userData.rotation = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1
                    );
                    part.position.set(
                        planeGroup.position.x + part.position.x,
                        planeGroup.position.y + part.position.y,
                        planeGroup.position.z + part.position.z
                    );
                    scene.add(part);
                });
                planeGroup.visible = false;
            }

            // Update plane parts after crash
            function updatePlaneParts() {
                planeParts.forEach(part => {
                    if (part.userData.velocity) {
                        part.position.add(part.userData.velocity);
                        part.rotation.x += part.userData.rotation.x;
                        part.rotation.y += part.userData.rotation.y;
                        part.rotation.z += part.userData.rotation.z;
                        part.userData.velocity.y += g;
                        if (part.position.y < 0.5) {
                            part.position.y = 0.5;
                            part.userData.velocity.set(0, 0, 0);
                        }
                    }
                });
            }

            // Update plane function with enhanced physics
            function updatePlane() {
                if (gameOver) {
                    updatePlaneParts();
                    return;
                }

                // Control pitch and yaw
                if (keys['ArrowUp'] && engineOn) pitch += pitchRate;
                if (keys['ArrowDown']) pitch -= pitchRate;
                if (keys['ArrowLeft']) yaw += yawRate;
                if (keys['ArrowRight']) yaw -= yawRate;
                pitch = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, pitch));
                planeGroup.rotation.x = pitch;
                planeGroup.rotation.y = yaw;

                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(planeGroup.quaternion);
                let currentSpeed = baseSpeed;

                // Adjust speed based on altitude
                const altitude = planeGroup.position.y;
                const maxAltitude = 180;
                if (altitude > 0.5) {
                    const speedFactor = 1 - (altitude / maxAltitude) * 0.5;
                    currentSpeed = baseSpeed * Math.max(speedFactor, 0.5);
                    if (velocity.y < 0) currentSpeed += Math.abs(velocity.y) * 0.5;
                }

                if (engineOn) {
                    velocity = forward.clone().multiplyScalar(currentSpeed);
                    velocity.y += g;
                } else {
                    velocity.y += g;
                    velocity.multiplyScalar(0.98);
                    if (planeGroup.position.y <= 0.5) velocity.set(0, 0, 0);
                }

                planeGroup.position.add(velocity);

                if (planeGroup.position.y <= 0.5) {
                    planeGroup.position.y = 0.5;
                    velocity.y = 0;
                    const speed = velocity.length();
                    if (speed > 0.5 && !engineOn) {
                        gameOver = true;
                        breakApartPlane();
                        displayGameOver();
                    }
                }

                const planeBoundingBox = new THREE.Box3().setFromObject(planeGroup);
                for (const building of buildings) {
                    const buildingBoundingBox = new THREE.Box3().setFromObject(building);
                    if (planeBoundingBox.intersectsBox(buildingBoundingBox)) {
                        gameOver = true;
                        breakApartPlane();
                        displayGameOver();
                        break;
                    }
                }

                // Update speed and altitude display
                const speedValue = velocity.length();
                speedElement.innerText = `Speed: ${speedValue.toFixed(2)} blocks/s`;
                const altitudeValue = altitude - 0.5;
                altitudeElement.innerText = `Altitude: ${altitudeValue.toFixed(2)} blocks`;
            }

            // Update vehicles function
            function updateVehicles() {
                vehicles.forEach(vehicle => {
                    const vehicleSpeed = 0.2;
                    if (vehicle.direction === 'east') vehicle.position.x += vehicleSpeed;
                    else if (vehicle.direction === 'west') vehicle.position.x -= vehicleSpeed;
                    else if (vehicle.direction === 'north') vehicle.position.z += vehicleSpeed;
                    else if (vehicle.direction === 'south') vehicle.position.z -= vehicleSpeed;

                    const nearestX = Math.round(vehicle.position.x / 50) * 50;
                    const nearestZ = Math.round(vehicle.position.z / 50) * 50;
                    const atIntersectionX = Math.abs(vehicle.position.x - nearestX) < 5;
                    const atIntersectionZ = Math.abs(vehicle.position.z - nearestZ) < 5;

                    if ((vehicle.direction === 'east' || vehicle.direction === 'west') && atIntersectionX) {
                        if (Math.random() < 0.1) {
                            const newDirection = Math.random() < 0.5 ? 'north' : 'south';
                            vehicle.direction = newDirection;
                            vehicle.rotation.y = 0;
                            vehicle.position.x = nearestX + (newDirection === 'north' ? 2 : -2);
                        }
                    } else if ((vehicle.direction === 'north' || vehicle.direction === 'south') && atIntersectionZ) {
                        if (Math.random() < 0.1) {
                            const newDirection = Math.random() < 0.5 ? 'east' : 'west';
                            vehicle.direction = newDirection;
                            vehicle.rotation.y = Math.PI / 2;
                            vehicle.position.z = nearestZ + (newDirection === 'east' ? 2 : -2);
                        }
                    }

                    if (vehicle.position.x > groundSize / 2) vehicle.position.x = -groundSize / 2;
                    if (vehicle.position.x < -groundSize / 2) vehicle.position.x = groundSize / 2;
                    if (vehicle.position.z > groundSize / 2) vehicle.position.z = -groundSize / 2;
                    if (vehicle.position.z < -groundSize / 2) vehicle.position.z = groundSize / 2;

                    if (vehicle.direction === 'east' || vehicle.direction === 'west') {
                        const nearestStreetZ = Math.round(vehicle.position.z / 50) * 50;
                        if (Math.abs(vehicle.position.z - nearestStreetZ) > streetWidth / 2) {
                            vehicle.position.z = nearestStreetZ + (vehicle.position.z > nearestStreetZ ? 2 : -2);
                        }
                    } else {
                        const nearestStreetX = Math.round(vehicle.position.x / 50) * 50;
                        if (Math.abs(vehicle.position.x - nearestStreetX) > streetWidth / 2) {
                            vehicle.position.x = nearestStreetX + (vehicle.position.x > nearestStreetX ? 2 : -2);
                        }
                    }
                });
            }

            // Update boats function
            function updateBoats() {
                boats.forEach(boat => {
                    const prevX = boat.position.x;
                    const prevZ = boat.position.z;

                    if (boat.direction === 'x') {
                        boat.position.x += boat.speed * (Math.random() > 0.5 ? 1 : -1);
                    } else {
                        boat.position.z += boat.speed * (Math.random() > 0.5 ? 1 : -1);
                    }

                    const inGroundArea = Math.abs(boat.position.x) < groundSize / 2 && Math.abs(boat.position.z) < groundSize / 2;
                    if (inGroundArea) {
                        boat.position.x = prevX;
                        boat.position.z = prevZ;
                        boat.direction = boat.direction === 'x' ? 'z' : 'x';
                        boat.rotation.y = boat.direction === 'x' ? Math.PI / 2 : 0;
                    }

                    if (boat.position.x > oceanSize / 2) boat.position.x = -oceanSize / 2;
                    if (boat.position.x < -oceanSize / 2) boat.position.x = oceanSize / 2;
                    if (boat.position.z > oceanSize / 2) boat.position.z = -oceanSize / 2;
                    if (boat.position.z < -oceanSize / 2) boat.position.z = oceanSize / 2;

                    if (Math.random() < 0.05) {
                        boat.direction = boat.direction === 'x' ? 'z' : 'x';
                        boat.rotation.y = boat.direction === 'x' ? Math.PI / 2 : 0;
                    }
                });
            }

            // Update clouds function
            function updateClouds() {
                clouds.forEach(cloud => {
                    cloud.position.x += 0.1;
                    if (cloud.position.x > 250) cloud.position.x = -250;
                });
            }

            // Display game over screen with final score
            function displayGameOver() {
                const gameOverText = document.createElement('div');
                gameOverText.id = 'gameOver';
                gameOverText.innerText = `You have crashed!\nFinal Score: ${Math.floor(score)}\nPress Spacebar to start again.`;
                document.body.appendChild(gameOverText);
            }

            // Animation loop with score counter
            function animate() {
                requestAnimationFrame(animate);
                const currentTime = performance.now();
                const deltaTime = (currentTime - lastTime) / 1000;
                if (!gameOver && hasStarted) {
                    score += deltaTime;
                    scoreElement.innerText = `Score: ${Math.floor(score)}`;
                }
                lastTime = currentTime;

                updatePlane();
                updateVehicles();
                updateBoats();
                updateClouds();
                camera.position.copy(planeGroup.position)
                    .add(new THREE.Vector3(0, 0, -1).applyQuaternion(planeGroup.quaternion).multiplyScalar(-10))
                    .add(new THREE.Vector3(0, 5, 0));
                camera.lookAt(planeGroup.position.clone().add(new THREE.Vector3(0, 0, -1).applyQuaternion(planeGroup.quaternion).multiplyScalar(10)));
                renderer.render(scene, camera);
            }

            animate();
        });
    </script>
</body>
</html>