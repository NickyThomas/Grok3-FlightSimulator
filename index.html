<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Flight Simulator with Airport and Clouds</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Include Three.js library via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script>
        // Initialize Three.js components
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75, // Field of view
            window.innerWidth / window.innerHeight, // Aspect ratio
            0.1, // Near clipping plane
            1000 // Far clipping plane
        );
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040); // Soft ambient light
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Sunlight
        directionalLight.position.set(100, 100, 100);
        scene.add(directionalLight);

        // Create the ground
        const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to lie flat
        scene.add(ground);

        // Create the airport runway
        const runwayGeometry = new THREE.PlaneGeometry(20, 200); // 20 wide, 200 long
        const runwayMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
        const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
        runway.rotation.x = -Math.PI / 2;
        runway.position.y = 0.01; // Slightly above ground to avoid z-fighting
        scene.add(runway);

        // Define exclusion zone around the runway
        const exclusionZone = { minX: -10, maxX: 10, minZ: -110, maxZ: 110 };

        // Generate buildings outside the runway area
        const buildings = [];
        for (let i = 0; i < 100; i++) {
            let x, z;
            do {
                x = (Math.random() - 0.5) * 1000;
                z = (Math.random() - 0.5) * 1000;
            } while (x > exclusionZone.minX && x < exclusionZone.maxX && z > exclusionZone.minZ && z < exclusionZone.maxZ);
            const height = Math.random() * 50 + 10;
            const buildingGeometry = new THREE.BoxGeometry(20, height, 20);
            const buildingMaterial = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.set(x, height / 2, z);
            scene.add(building);
            buildings.push(building);
        }

        // Generate vehicles outside the runway area
        const vehicles = [];
        for (let i = 0; i < 20; i++) {
            const vehicleGeometry = new THREE.BoxGeometry(5, 2, 10);
            const vehicleMaterial = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
            const vehicle = new THREE.Mesh(vehicleGeometry, vehicleMaterial);
            const roadZ = (Math.floor(Math.random() * 10) - 5) * 50; // Place on grid-like roads
            vehicle.position.set((Math.random() - 0.5) * 1000, 1, roadZ);
            vehicle.direction = Math.random() > 0.5 ? 'x+' : 'x-';
            scene.add(vehicle);
            vehicles.push(vehicle);
        }

        // Generate moving 3D clouds
        const clouds = [];
        for (let i = 0; i < 50; i++) {
            const cloudGeometry = new THREE.SphereGeometry(Math.random() * 5 + 2, 16, 16);
            const cloudMaterial = new THREE.MeshLambertMaterial({
                color: 0xffffff, // White clouds
                transparent: true,
                opacity: 0.8 // Semi-transparent for a fluffy look
            });
            const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
            cloud.position.set(
                (Math.random() - 0.5) * 500, // Spread across X
                50 + Math.random() * 10, // Altitude between 50 and 60
                (Math.random() - 0.5) * 500 // Spread across Z
            );
            scene.add(cloud);
            clouds.push(cloud);
        }

        // Create the airplane
        const airplaneGeometry = new THREE.ConeGeometry(5, 20, 32); // Simple cone shape
        const airplaneMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
        const airplane = new THREE.Mesh(airplaneGeometry, airplaneMaterial);
        airplane.rotation.x = Math.PI / 2; // Orient to point forward
        airplane.position.set(0, 0.5, -90); // Start on runway
        scene.add(airplane);

        // Set up flight controls
        let upPressed = false;
        let downPressed = false;
        let leftPressed = false;
        let rightPressed = false;
        let spacePressed = false;

        document.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowUp') upPressed = true;
            if (event.key === 'ArrowDown') downPressed = true;
            if (event.key === 'ArrowLeft') leftPressed = true;
            if (event.key === 'ArrowRight') rightPressed = true;
            if (event.key === ' ') spacePressed = true;
        });

        document.addEventListener('keyup', (event) => {
            if (event.key === 'ArrowUp') upPressed = false;
            if (event.key === 'ArrowDown') downPressed = false;
            if (event.key === 'ArrowLeft') leftPressed = false;
            if (event.key === 'ArrowRight') rightPressed = false;
            if (event.key === ' ') spacePressed = false;
        });

        let speed = 0; // Airplane speed

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Move clouds across the sky
            clouds.forEach(cloud => {
                cloud.position.x += 0.1; // Move right
                if (cloud.position.x > 250) cloud.position.x = -250; // Loop back
            });

            // Move vehicles
            vehicles.forEach(vehicle => {
                if (vehicle.direction === 'x+') {
                    vehicle.position.x += 0.5;
                    if (vehicle.position.x > 500) vehicle.position.x = -500;
                } else {
                    vehicle.position.x -= 0.5;
                    if (vehicle.position.x < -500) vehicle.position.x = 500;
                }
            });

            // Update airplane position and rotation
            if (upPressed) airplane.position.y += 0.1; // Ascend
            if (downPressed) airplane.position.y -= 0.1; // Descend
            if (leftPressed) airplane.rotation.y += 0.01; // Turn left
            if (rightPressed) airplane.rotation.y -= 0.01; // Turn right
            if (spacePressed) speed += 0.01; // Accelerate
            speed *= 0.99; // Simulate air resistance

            // Move airplane forward based on its direction
            const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(airplane.quaternion);
            airplane.position.add(direction.multiplyScalar(speed));

            // Enforce altitude boundaries
            if (airplane.position.y < 0) airplane.position.y = 0; // Ground level
            if (airplane.position.y > 100) airplane.position.y = 100; // Max height

            // Update camera to follow airplane
            const offset = new THREE.Vector3(0, 5, 10).applyQuaternion(airplane.quaternion);
            camera.position.copy(airplane.position).add(offset);
            camera.lookAt(airplane.position);

            // Render the scene
            renderer.render(scene, camera);
        }

        // Start animation
        animate();

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>