<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Flight Simulator</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Include Three.js library via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialize the Three.js scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75, // Field of view
            window.innerWidth / window.innerHeight, // Aspect ratio
            0.1, // Near clipping plane
            1000 // Far clipping plane
        );
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Set background color to blue for the sky
        scene.background = new THREE.Color(0x87CEEB); // Light blue

        // Create the ground plane with streets and pavements
        const groundSize = 1000;
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 }); // Green for grass
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2; // Rotate to lie flat on XZ plane
        scene.add(ground);

        // Add streets
        const streetWidth = 10;
        const streetMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 }); // Gray for streets
        for (let i = -groundSize / 2; i <= groundSize / 2; i += 50) {
            // Horizontal streets
            const streetH = new THREE.Mesh(new THREE.PlaneGeometry(groundSize, streetWidth), streetMaterial);
            streetH.rotation.x = -Math.PI / 2;
            streetH.position.set(0, 0.01, i);
            scene.add(streetH);
            // Vertical streets
            const streetV = new THREE.Mesh(new THREE.PlaneGeometry(streetWidth, groundSize), streetMaterial);
            streetV.rotation.x = -Math.PI / 2;
            streetV.position.set(i, 0.01, 0);
            scene.add(streetV);
        }

        // Add pavements along streets
        const pavementWidth = 2;
        const pavementMaterial = new THREE.MeshBasicMaterial({ color: 0xA9A9A9 }); // Light gray for pavements
        for (let i = -groundSize / 2; i <= groundSize / 2; i += 50) {
            // Pavements along horizontal streets
            const pavementH1 = new THREE.Mesh(new THREE.PlaneGeometry(groundSize, pavementWidth), pavementMaterial);
            pavementH1.rotation.x = -Math.PI / 2;
            pavementH1.position.set(0, 0.02, i - streetWidth / 2 - pavementWidth / 2);
            scene.add(pavementH1);
            const pavementH2 = new THREE.Mesh(new THREE.PlaneGeometry(groundSize, pavementWidth), pavementMaterial);
            pavementH2.rotation.x = -Math.PI / 2;
            pavementH2.position.set(0, 0.02, i + streetWidth / 2 + pavementWidth / 2);
            scene.add(pavementH2);
            // Pavements along vertical streets
            const pavementV1 = new THREE.Mesh(new THREE.PlaneGeometry(pavementWidth, groundSize), pavementMaterial);
            pavementV1.rotation.x = -Math.PI / 2;
            pavementV1.position.set(i - streetWidth / 2 - pavementWidth / 2, 0.02, 0);
            scene.add(pavementV1);
            const pavementV2 = new THREE.Mesh(new THREE.PlaneGeometry(pavementWidth, groundSize), pavementMaterial);
            pavementV2.rotation.x = -Math.PI / 2;
            pavementV2.position.set(i + streetWidth / 2 + pavementWidth / 2, 0.02, 0);
            scene.add(pavementV2);
        }

        // Create a more realistic airplane model
        // For simplicity, we'll use a combination of geometries to resemble a plane
        const planeGroup = new THREE.Group();

        // Fuselage
        const fuselageGeometry = new THREE.CylinderGeometry(0.5, 0.5, 10, 32);
        const fuselageMaterial = new THREE.MeshBasicMaterial({ color: 0xC0C0C0 }); // Silver
        const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
        fuselage.rotation.z = Math.PI / 2;
        planeGroup.add(fuselage);

        // Wings
        const wingGeometry = new THREE.BoxGeometry(15, 0.5, 2);
        const wingMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF }); // White
        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
        leftWing.position.set(-7.5, 0, 0);
        planeGroup.add(leftWing);
        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
        rightWing.position.set(7.5, 0, 0);
        planeGroup.add(rightWing);

        // Tail
        const tailGeometry = new THREE.BoxGeometry(3, 0.5, 1);
        const tail = new THREE.Mesh(tailGeometry, wingMaterial);
        tail.position.set(0, 0, 4.5);
        planeGroup.add(tail);

        // Add the plane to the scene
        planeGroup.position.set(0, 0, 0); // Start on the airfield
        scene.add(planeGroup);

        // Generate random buildings around the airfield
        for (let i = 0; i < 100; i++) {
            let x, z;
            // Ensure buildings are outside the airfield area (-50 to 50 in x and z)
            do {
                x = (Math.random() - 0.5) * groundSize;
                z = (Math.random() - 0.5) * groundSize;
            } while (Math.abs(x) < 50 && Math.abs(z) < 50);
            
            const height = Math.random() * 20 + 10; // Height between 10 and 30
            const width = Math.random() * 10 + 5;   // Width between 5 and 15
            const depth = Math.random() * 10 + 5;   // Depth between 5 and 15
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff }); // Random color
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height / 2, z); // Base on ground, centered vertically
            scene.add(building);
        }

        // Add ocean at the edges
        const oceanSize = 2000;
        const oceanGeometry = new THREE.PlaneGeometry(oceanSize, oceanSize);
        const oceanMaterial = new THREE.MeshBasicMaterial({ color: 0x0000FF }); // Blue
        const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
        ocean.rotation.x = -Math.PI / 2;
        ocean.position.y = -0.1; // Slightly below ground level
        scene.add(ocean);

        // Define constants for flight mechanics
        const speed = 1;        // Forward speed per frame
        const g = -0.02;        // Gravity acceleration per frame
        const pitchRate = 0.01; // Pitch change rate per frame
        const yawRate = 0.01;   // Yaw change rate per frame

        // Initialize variables
        let pitch = 0;          // Pitch angle in radians
        let yaw = 0;            // Yaw angle in radians
        const keys = {};        // Object to track key states

        // Set up keyboard event listeners
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Function to update the plane's position and orientation
        function updatePlane() {
            // Adjust pitch and yaw based on key presses
            if (keys['ArrowUp']) pitch += pitchRate;
            if (keys['ArrowDown']) pitch -= pitchRate;
            if (keys['ArrowLeft']) yaw += yawRate;
            if (keys['ArrowRight']) yaw -= yawRate;

            // Clamp pitch to prevent extreme angles (between -45° and 45°)
            pitch = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, pitch));

            // Apply rotations to the plane
            planeGroup.rotation.x = pitch;
            planeGroup.rotation.y = yaw;

            // Calculate the forward direction based on plane's orientation
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(planeGroup.quaternion);

            // Update plane position with velocity
            const vel = forward.clone().multiplyScalar(speed);
            vel.y += g; // Apply gravity
            planeGroup.position.add(vel);

            // Prevent the plane from going below ground level
            if (planeGroup.position.y < 0) {
                planeGroup.position.y = 0;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Update plane state
            updatePlane();

            // Update camera to follow the plane
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(planeGroup.quaternion);
            camera.position.copy(planeGroup.position)
                .add(forward.clone().multiplyScalar(-10)) // 10 units behind
                .add(new THREE.Vector3(0, 5, 0));         // 5 units above
            camera.lookAt(planeGroup.position.clone().add(forward.multiplyScalar(10))); // Look 10 units ahead

            // Render the scene
            renderer.render(scene, camera);
        }

        // Start the animation loop
        animate();
    </script>
</body>
</html>