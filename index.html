<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Flight Simulator</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <!-- Include Three.js library via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Initialize scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Enable shadows
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        scene.background = new THREE.Color(0x87CEEB); // Light blue sky

        // Add sunlight
        const sunLight = new THREE.DirectionalLight(0xffffff, 1);
        sunLight.position.set(100, 100, 100);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -100;
        sunLight.shadow.camera.right = 100;
        sunLight.shadow.camera.top = 100;
        sunLight.shadow.camera.bottom = -100;
        scene.add(sunLight);

        // Create ground
        const groundSize = 1000;
        const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 }); // Green grass
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Add streets
        const streetWidth = 10;
        const streetMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 }); // Gray roads
        const streets = [];
        for (let i = -groundSize / 2; i <= groundSize / 2; i += 50) {
            const streetH = new THREE.Mesh(new THREE.PlaneGeometry(groundSize, streetWidth), streetMaterial);
            streetH.rotation.x = -Math.PI / 2;
            streetH.position.set(0, 0.01, i);
            streetH.receiveShadow = true;
            scene.add(streetH);
            streets.push({ type: 'horizontal', z: i });
            const streetV = new THREE.Mesh(new THREE.PlaneGeometry(streetWidth, groundSize), streetMaterial);
            streetV.rotation.x = -Math.PI / 2;
            streetV.position.set(i, 0.01, 0);
            streetV.receiveShadow = true;
            scene.add(streetV);
            streets.push({ type: 'vertical', x: i });
        }

        // Create realistic airplane
        const planeGroup = new THREE.Group();

        // Fuselage
        const fuselageGeometry = new THREE.CylinderGeometry(0.3, 0.5, 12, 32);
        const fuselageMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 }); // Silver
        const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
        fuselage.rotation.z = Math.PI / 2;
        fuselage.castShadow = true;
        planeGroup.add(fuselage);

        // Wings
        const wingGeometry = new THREE.BoxGeometry(20, 0.5, 3);
        const wingMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF }); // White
        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
        leftWing.position.set(-10, 0, 0);
        leftWing.castShadow = true;
        planeGroup.add(leftWing);
        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
        rightWing.position.set(10, 0, 0);
        rightWing.castShadow = true;
        planeGroup.add(rightWing);

        // Tail Section
        const tailVerticalGeometry = new THREE.BoxGeometry(0.5, 3, 1);
        const tailVertical = new THREE.Mesh(tailVerticalGeometry, wingMaterial);
        tailVertical.position.set(0, 1.5, 5.5);
        tailVertical.castShadow = true;
        planeGroup.add(tailVertical);
        const tailHorizontalGeometry = new THREE.BoxGeometry(5, 0.5, 1);
        const tailHorizontal = new THREE.Mesh(tailHorizontalGeometry, wingMaterial);
        tailHorizontal.position.set(0, 0, 5.5);
        tailHorizontal.castShadow = true;
        planeGroup.add(tailHorizontal);

        // Engines
        const engineGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.5, 32);
        const engineMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
        const leftEngine = new THREE.Mesh(engineGeometry, engineMaterial);
        leftEngine.position.set(-3, -0.5, 0);
        leftEngine.rotation.z = Math.PI / 2;
        planeGroup.add(leftEngine);
        const rightEngine = new THREE.Mesh(engineGeometry, engineMaterial);
        rightEngine.position.set(3, -0.5, 0);
        rightEngine.rotation.z = Math.PI / 2;
        planeGroup.add(rightEngine);

        // Cockpit
        const cockpitGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const cockpitMaterial = new THREE.MeshLambertMaterial({ color: 0x0000FF });
        const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
        cockpit.position.set(0, 0, -6);
        planeGroup.add(cockpit);

        // Landing Gear
        const gearGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const gearMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
        const frontGear = new THREE.Mesh(gearGeometry, gearMaterial);
        frontGear.position.set(0, -0.5, -5);
        planeGroup.add(frontGear);
        const leftGear = new THREE.Mesh(gearGeometry, gearMaterial);
        leftGear.position.set(-1.5, -0.5, 0);
        planeGroup.add(leftGear);
        const rightGear = new THREE.Mesh(gearGeometry, gearMaterial);
        rightGear.position.set(1.5, -0.5, 0);
        planeGroup.add(rightGear);

        planeGroup.position.set(0, 0, 0);
        scene.add(planeGroup);

        // Add buildings
        const buildings = [];
        for (let i = 0; i < 100; i++) {
            let x, z;
            do {
                x = (Math.random() - 0.5) * groundSize;
                z = (Math.random() - 0.5) * groundSize;
            } while (Math.abs(x) < 50 && Math.abs(z) < 50);
            const height = Math.random() * 20 + 10;
            const geometry = new THREE.BoxGeometry(Math.random() * 10 + 5, height, Math.random() * 10 + 5);
            const material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
            const building = new THREE.Mesh(geometry, material);
            building.position.set(x, height / 2, z);
            building.castShadow = true;
            building.receiveShadow = true;
            scene.add(building);
            buildings.push(building);
        }

        // Add parked cars
        const parkedCars = [];
        for (let i = -groundSize / 2; i <= groundSize / 2; i += 50) {
            for (let j = -groundSize / 2; j < groundSize / 2; j += 20) {
                const carH1 = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                carH1.position.set(j, 0.5, i - streetWidth / 2 - 1);
                carH1.rotation.y = Math.PI / 2;
                scene.add(carH1);
                parkedCars.push(carH1);
                const carH2 = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                carH2.position.set(j, 0.5, i + streetWidth / 2 + 1);
                carH2.rotation.y = Math.PI / 2;
                scene.add(carH2);
                parkedCars.push(carH2);
                const carV1 = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                carV1.position.set(i - streetWidth / 2 - 1, 0.5, j);
                scene.add(carV1);
                parkedCars.push(carV1);
                const carV2 = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
                carV2.position.set(i + streetWidth / 2 + 1, 0.5, j);
                scene.add(carV2);
                parkedCars.push(carV2);
            }
        }

        // Add moving vehicles
        const vehicles = [];
        for (let i = 0; i < 20; i++) {
            const vehicle = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1), new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff }));
            const startStreet = streets[Math.floor(Math.random() * streets.length)];
            vehicle.position.y = 0.5;
            vehicle.castShadow = true;
            if (startStreet.type === 'horizontal') {
                vehicle.position.z = startStreet.z + (Math.random() > 0.5 ? 2 : -2);
                vehicle.position.x = (Math.random() - 0.5) * groundSize;
                vehicle.direction = Math.random() > 0.5 ? 'east' : 'west';
                vehicle.rotation.y = Math.PI / 2;
            } else {
                vehicle.position.x = startStreet.x + (Math.random() > 0.5 ? 2 : -2);
                vehicle.position.z = (Math.random() - 0.5) * groundSize;
                vehicle.direction = Math.random() > 0.5 ? 'north' : 'south';
            }
            scene.add(vehicle);
            vehicles.push(vehicle);
        }

        // Flight mechanics
        const speed = 1;
        const g = -0.02;
        const pitchRate = 0.01;
        const yawRate = 0.01;
        let pitch = 0;
        let yaw = 0;
        const keys = {};
        let gameOver = false;

        window.addEventListener('keydown', (e) => {
            if (gameOver && e.key === ' ') resetGame();
            else keys[e.key] = true;
        });
        window.addEventListener('keyup', (e) => keys[e.key] = false);

        function updatePlane() {
            if (gameOver) return;
            if (keys['ArrowUp']) pitch += pitchRate;
            if (keys['ArrowDown']) pitch -= pitchRate;
            if (keys['ArrowLeft']) yaw += yawRate;
            if (keys['ArrowRight']) yaw -= yawRate;
            pitch = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, pitch));
            planeGroup.rotation.x = pitch;
            planeGroup.rotation.y = yaw;
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(planeGroup.quaternion);
            const vel = forward.clone().multiplyScalar(speed);
            vel.y += g;
            planeGroup.position.add(vel);
            if (planeGroup.position.y < 0) planeGroup.position.y = 0;

            const planeBoundingBox = new THREE.Box3().setFromObject(planeGroup);
            for (const building of buildings) {
                const buildingBoundingBox = new THREE.Box3().setFromObject(building);
                if (planeBoundingBox.intersectsBox(buildingBoundingBox)) {
                    gameOver = true;
                    displayGameOver();
                    break;
                }
            }
        }

        function updateVehicles() {
            vehicles.forEach(vehicle => {
                const speed = 0.2;
                let offset = 0;

                // Check for parked cars ahead
                parkedCars.forEach(car => {
                    const distX = vehicle.position.x - car.position.x;
                    const distZ = vehicle.position.z - car.position.z;
                    const ahead = (vehicle.direction === 'east' && distX > 0 && distX < 10 && Math.abs(distZ) < 2) ||
                                  (vehicle.direction === 'west' && distX < 0 && distX > -10 && Math.abs(distZ) < 2) ||
                                  (vehicle.direction === 'north' && distZ > 0 && distZ < 10 && Math.abs(distX) < 2) ||
                                  (vehicle.direction === 'south' && distZ < 0 && distZ > -10 && Math.abs(distX) < 2);
                    if (ahead) offset = vehicle.direction === 'east' || vehicle.direction === 'west' ? -2 : 2;
                });

                // Move vehicle
                if (vehicle.direction === 'east') vehicle.position.x += speed;
                else if (vehicle.direction === 'west') vehicle.position.x -= speed;
                else if (vehicle.direction === 'north') vehicle.position.z += speed;
                else if (vehicle.direction === 'south') vehicle.position.z -= speed;

                // Apply offset for parked cars
                if (vehicle.direction === 'east' || vehicle.direction === 'west') vehicle.position.z += offset;
                else vehicle.position.x += offset;

                // Snap to nearest road and handle turns
                const nearestX = Math.round(vehicle.position.x / 50) * 50;
                const nearestZ = Math.round(vehicle.position.z / 50) * 50;
                if ((vehicle.direction === 'east' || vehicle.direction === 'west') && Math.abs(vehicle.position.x - nearestX) < 5) {
                    if (Math.random() < 0.1) {
                        vehicle.direction = Math.random() < 0.5 ? 'north' : 'south';
                        vehicle.rotation.y = 0;
                        vehicle.position.x = nearestX + (vehicle.direction === 'north' ? 2 : -2);
                    }
                } else if ((vehicle.direction === 'north' || vehicle.direction === 'south') && Math.abs(vehicle.position.z - nearestZ) < 5) {
                    if (Math.random() < 0.1) {
                        vehicle.direction = Math.random() < 0.5 ? 'east' : 'west';
                        vehicle.rotation.y = Math.PI / 2;
                        vehicle.position.z = nearestZ + (vehicle.direction === 'east' ? 2 : -2);
                    }
                }

                // Wrap around edges
                if (vehicle.position.x > groundSize / 2) vehicle.position.x = -groundSize / 2;
                if (vehicle.position.x < -groundSize / 2) vehicle.position.x = groundSize / 2;
                if (vehicle.position.z > groundSize / 2) vehicle.position.z = -groundSize / 2;
                if (vehicle.position.z < -groundSize / 2) vehicle.position.z = groundSize / 2;

                // Return to lane after passing
                if (offset !== 0) {
                    const lanePos = vehicle.direction === 'east' ? nearestZ + 2 : vehicle.direction === 'west' ? nearestZ - 2 :
                                    vehicle.direction === 'north' ? nearestX + 2 : nearestX - 2;
                    const target = vehicle.direction === 'east' || vehicle.direction === 'west' ? 'z' : 'x';
                    vehicle.position[target] += (lanePos - vehicle.position[target]) * 0.05;
                }
            });
        }

        function displayGameOver() {
            const gameOverText = document.createElement('div');
            gameOverText.style.position = 'absolute';
            gameOverText.style.top = '50%';
            gameOverText.style.left = '50%';
            gameOverText.style.transform = 'translate(-50%, -50%)';
            gameOverText.style.fontSize = '48px';
            gameOverText.style.color = 'red';
            gameOverText.innerText = 'You have crashed!\nPress Spacebar to start again.';
            document.body.appendChild(gameOverText);
        }

        function resetGame() {
            planeGroup.position.set(0, 0, 0);
            pitch = 0;
            yaw = 0;
            gameOver = false;
            document.body.removeChild(document.querySelector('div'));
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePlane();
            updateVehicles();
            camera.position.copy(planeGroup.position)
                .add(new THREE.Vector3(0, 0, -1).applyQuaternion(planeGroup.quaternion).multiplyScalar(-10))
                .add(new THREE.Vector3(0, 5, 0));
            camera.lookAt(planeGroup.position.clone().add(new THREE.Vector3(0, 0, -1).applyQuaternion(planeGroup.quaternion).multiplyScalar(10)));
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>